<!--
AI_Algorithms — Interactive Metrics Dashboard

Offline-friendly:
- Works with file:// by using file pickers (cannot auto-read local files for security reasons).
- Optional: run a local server (python -m http.server) to enable relative-path fetch.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI_Algorithms — Dashboard</title>
  <style>
    :root {
      --bg: #0b0d10;
      --panel: #121621;
      --panel2: #0f1320;
      --text: #e7eef8;
      --muted: #a9b7cc;
      --accent: #66d9ef;
      --accent2: #a6e22e;
      --warn: #fd971f;
      --bad: #ff6b6b;
      --border: #2a3243;
      --shadow: rgba(0, 0, 0, 0.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    body {
      background: var(--bg);
      color: var(--text);
      margin: 0;
      font-family: var(--sans);
    }

    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    header {
      padding: 20px 16px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, #0b0d10 0%, rgba(18,22,33,0.75) 100%);
    }
    .wrap { max-width: 1200px; margin: 0 auto; }

    h1 { margin: 0 0 6px 0; font-size: 22px; }
    .subtitle { margin: 0; color: var(--muted); font-size: 13px; }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      padding: 16px;
    }
    @media (min-width: 1000px) {
      .grid { grid-template-columns: 1fr 1fr; }
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 10px 24px var(--shadow);
      overflow: hidden;
    }

    .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }

    .controls {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .controls label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 4px;
    }

    input[type="file"], input[type="text"], select {
      width: 100%;
      box-sizing: border-box;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--panel2);
      color: var(--text);
      font-family: var(--mono);
      font-size: 12px;
    }

    button {
      border: 1px solid var(--border);
      background: #0d1220;
      color: var(--text);
      border-radius: 10px;
      padding: 10px 12px;
      cursor: pointer;
      font-weight: 700;
      font-family: var(--mono);
      font-size: 12px;
    }
    button:hover { border-color: var(--accent); }

    .hint {
      margin: 6px 0 0 0;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }

    .kpis {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    @media (min-width: 700px) {
      .kpis { grid-template-columns: repeat(4, 1fr); }
    }
    .kpi {
      background: var(--panel2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
    }
    .kpi .label { color: var(--muted); font-size: 12px; }
    .kpi .value { font-family: var(--mono); font-size: 18px; margin-top: 6px; }

    .charts {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 10px;
    }

    .chart {
      background: var(--panel2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px;
      min-height: 280px;
    }

    .chart.hint-only {
      min-height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 14px;
    }

    .chart.hint-only .hint {
      margin: 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      font-family: var(--mono);
      font-size: 12px;
    }
    th, td {
      border-bottom: 1px solid var(--border);
      padding: 8px 6px;
      text-align: left;
      vertical-align: top;
      word-break: break-word;
    }
    th { color: var(--muted); font-weight: 700; }

    .tag {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 11px;
      font-family: var(--mono);
      color: var(--muted);
    }
    .tag.good { border-color: rgba(166,226,46,0.6); color: var(--accent2); }
    .tag.bad { border-color: rgba(255,107,107,0.6); color: var(--bad); }

    textarea {
      width: 100%;
      min-height: 180px;
      resize: vertical;
      border-radius: 12px;
      padding: 10px;
      border: 1px solid var(--border);
      background: #0d1220;
      color: var(--text);
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.35;
      box-sizing: border-box;
    }

    .footer {
      padding: 16px;
      border-top: 1px solid var(--border);
      color: var(--muted);
      font-size: 12px;
    }
  </style>
  <script
    src="https://cdn.plot.ly/plotly-2.30.0.min.js"
    defer
    onload="window.__plotly_loaded=true; try{ if(window.__loaded){ renderFromLoaded(window.__loaded); } }catch(e){}"
  ></script>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="row" style="justify-content: space-between;">
        <div>
          <h1>AI_Algorithms — Metrics + Adversarial Dashboard</h1>
          <p class="subtitle">Load metrics + adversarial reports to visualize adaptive sampling and rollback-storm behavior.</p>
        </div>
        <div class="row">
          <a href="index.html" style="font-family: var(--mono); font-size: 12px;">Back to index</a>
        </div>
      </div>
      <p class="hint">
        Offline note: browsers can’t auto-read local files. Use the file pickers below (works with file://).
        Optional: run a local server to enable relative-path fetch.
      </p>
    </div>
  </header>

  <main class="wrap">
    <div class="grid">
      <section class="card">
        <h2 style="margin:0 0 8px 0; font-size: 16px;">Load Data</h2>
        <div class="controls">
          <div>
            <label for="metricsFile">metrics.json (or metrics_compare.json)</label>
            <input id="metricsFile" type="file" accept="application/json" />
            <div class="hint">Suggested: TemporaryQueue/metrics.json (run) or TemporaryQueue/metrics_compare.json (compare)</div>
          </div>

          <div>
            <label for="reportsFiles">adversarial_report_*.json (multi-select)</label>
            <input id="reportsFiles" type="file" accept="application/json" multiple />
            <div class="hint">Select one or more adversarial reports (S1..S6) to populate tables and histograms.</div>
          </div>

          <div>
            <label for="sweepCsv">sweep_results.csv (optional)</label>
            <input id="sweepCsv" type="file" accept="text/csv" />
            <div class="hint">Optional: TemporaryQueue/sweep_results.csv</div>
          </div>

          <div class="row">
            <button type="button" onclick="renderAll()">Render Dashboard</button>
            <button type="button" onclick="tryFetchDefaults()">Try Fetch Defaults (server mode)</button>
            <button type="button" onclick="generateCompareAndLoadDefaults()">Generate Compare Metrics + Load Defaults</button>
            <span id="status" class="tag">idle</span>
          </div>

          <div>
            <label for="basePath">Server mode base path (optional)</label>
            <input id="basePath" type="text" value="." />
            <div class="hint">
              If you serve the repo (e.g. python -m http.server), this attempts to fetch
              ./TemporaryQueue/metrics.json (or metrics_compare.json) and adversarial_report_*.json (only known names).
              For file:// usage, prefer the file pickers.
            </div>
          </div>

          <div>
            <label for="metricsServerSource">Server mode metrics source</label>
            <select id="metricsServerSource">
              <option value="run">Run metrics (TemporaryQueue/metrics.json)</option>
              <option value="compare">Compare metrics (TemporaryQueue/metrics_compare.json)</option>
            </select>
            <div class="hint">Tip: use compare metrics to avoid overwriting live/run totals.</div>
          </div>
        </div>

        <div class="kpis" id="kpis"></div>
      </section>

      <section class="card">
        <h2 style="margin:0 0 8px 0; font-size: 16px;">Charts</h2>
        <div class="charts">
          <div class="chart" id="chartCounters"></div>
          <div class="chart" id="chartHistogram"></div>
          <div class="chart" id="chartPie"></div>
        </div>
      </section>

      <section class="card">
        <h2 style="margin:0 0 8px 0; font-size: 16px;">Escalation Events</h2>
        <div class="hint">Scans loaded adversarial reports for escalation signals (e.g., task.escalated, validation.result == "escalated").</div>
        <div id="escalationEmpty" class="hint" style="display:none; margin-top:10px;">No escalation events found in loaded reports.</div>
        <div style="overflow:auto;">
          <table id="escalationTable" aria-label="Escalation events">
            <thead>
              <tr>
                <th>report_file</th>
                <th>scenario_id</th>
                <th>task_id</th>
                <th>retry_count</th>
                <th>reason</th>
              </tr>
            </thead>
            <tbody></tbody>

              <details style="margin-top: 6px;">
                <summary style="cursor:pointer; font-family: var(--mono); font-size: 12px; color: var(--muted);">Fetch log (server mode)</summary>
                <div class="hint" style="margin-top: 8px;">Shows which URLs were attempted and their status codes.</div>
                <pre id="fetchLog" style="white-space: pre-wrap; margin: 8px 0 0 0; font-family: var(--mono); font-size: 11px; color: var(--muted);"></pre>
              </details>
          </table>
        </div>
      </section>

      <section class="card">
        <h2 style="margin:0 0 8px 0; font-size: 16px;">Live Snapshot (ai_brain_metrics)</h2>
        <div class="hint">Displays `TemporaryQueue/ai_brain_metrics_live.json` produced by the metrics watcher task.</div>

        <div class="controls" style="margin-top: 10px;">
          <div>
            <label for="liveSnapshotFile">Load snapshot JSON (file:// mode)</label>
            <input id="liveSnapshotFile" type="file" accept="application/json" />
            <div class="hint">Suggested: TemporaryQueue/ai_brain_metrics_live.json</div>
          </div>

          <div class="row">
            <button type="button" onclick="loadLiveSnapshotFromPicker()">Load snapshot from file</button>
            <button type="button" onclick="fetchLiveSnapshotOnce()">Fetch snapshot (server mode)</button>
            <button type="button" onclick="toggleLiveSnapshotAutorefresh()">Toggle Auto-Refresh</button>
            <span id="liveSnapshotStatus" class="tag">idle</span>
          </div>

          <div>
            <label for="liveSnapshotInterval">Auto-refresh interval (seconds)</label>
            <input id="liveSnapshotInterval" type="text" value="10" />
            <div class="hint">Only works in server mode (http://...). Uses the base path above.</div>
          </div>
        </div>

        <div style="overflow:auto; margin-top: 10px;">
          <table aria-label="Live snapshot summary">
            <thead>
              <tr>
                <th>ts</th>
                <th>orchestrator_lock</th>
                <th>temp_files</th>
                <th>active_files</th>
                <th>holding_files</th>
                <th>metrics_run</th>
                <th>metrics_compare</th>
              </tr>
            </thead>
            <tbody id="liveSnapshotTableBody"></tbody>
          </table>
        </div>

        <textarea id="liveSnapshotRaw" spellcheck="false" placeholder="Load or fetch a snapshot to see raw JSON..." style="height: 160px; margin-top: 10px;"></textarea>
      </section>

      <section class="card">
        <h2 style="margin:0 0 8px 0; font-size: 16px;">Per-Scenario Summary</h2>
        <div style="overflow:auto;">
          <table id="scenarioTable" aria-label="Scenario summary">
            <thead>
              <tr>
                <th>scenario_id</th>
                <th>pass/fail</th>
                <th>sample_count (n)</th>
                <th>deterministic_seed</th>
                <th>report_file</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </section>

      <section class="card" style="grid-column: 1 / -1;">
        <h2 style="margin:0 0 8px 0; font-size: 16px;">Raw Metrics + Downloads</h2>
        <div class="row" style="justify-content: space-between;">
          <div class="hint">Raw metrics JSON is shown below for copy/paste and sanity checks.</div>
          <div class="row">
            <a id="downloadSweep" href="#" style="display:none; font-family: var(--mono); font-size: 12px;">Download loaded sweep CSV</a>
          </div>
        </div>
        <textarea id="rawMetrics" spellcheck="false" placeholder="Load metrics.json to see raw content..."></textarea>
      </section>
    </div>
  </main>

  <div class="footer">
    <div class="wrap">
      <div>Tip: Use index.html for copy/paste commands. This page is read-only and safe offline.</div>
    </div>
  </div>

  <script>
    const DEFAULT_COUNTER_KEYS = [
      'resolution_adaptive_used_total',
      'resolution_adaptive_samples_total',
      'resolution_adaptive_early_stop_total',
      'resolution_fixed_samples_total',
      'resolution_rollback_storm_escalations_total'
    ];

    const METRICS_SERVER_PATHS = {
      run: 'TemporaryQueue/metrics.json',
      compare: 'TemporaryQueue/metrics_compare.json',
    };

    const LIVE_SNAPSHOT_PATH = 'TemporaryQueue/ai_brain_metrics_live.json';

    function setStatus(text, kind='') {
      const el = document.getElementById('status');
      if (!el) return;
      el.textContent = text;
      el.className = 'tag' + (kind ? (' ' + kind) : '');
    }

    function setInitialPlaceholders() {
      const msg = 'Load data (left) then click “Render Dashboard”, or click “Try Fetch Defaults (server mode)”.';
      const ids = ['chartCounters', 'chartHistogram', 'chartPie'];
      for (const id of ids) {
        const el = document.getElementById(id);
        if (!el) continue;
        if (String(el.innerHTML || '').trim()) continue;
        el.innerHTML = `<div class="hint">${msg}</div>`;
      }
    }

    function safeNumber(x) {
      const n = Number(x);
      return Number.isFinite(n) ? n : 0;
    }

    function get(obj, path, fallback=null) {
      try {
        let cur = obj;
        for (const key of path) {
          if (cur == null) return fallback;
          cur = cur[key];
        }
        return (cur === undefined) ? fallback : cur;
      } catch {
        return fallback;
      }
    }

    function detectMetricsRoot(payload) {
      if (payload && typeof payload === 'object') {
        const m = payload.metrics;
        if (m && typeof m === 'object') return m;
      }
      return payload;
    }

    function setLiveSnapshotStatus(text, kind='') {
      const el = document.getElementById('liveSnapshotStatus');
      if (!el) return;
      el.textContent = text;
      el.className = 'tag' + (kind ? (' ' + kind) : '');
    }

    function _parseIntSafe(x, dflt) {
      const n = parseInt(String(x || '').trim(), 10);
      return Number.isFinite(n) ? n : dflt;
    }

    function _fmtBool(b) {
      return b ? 'yes' : 'no';
    }

    function _getBase() {
      const baseEl = document.getElementById('basePath');
      let base = baseEl ? String(baseEl.value || '.').trim() : '.';
      if (!base) base = '.';
      base = base.replace(/\/+$/g, '');
      return base;
    }

    function renderLiveSnapshot(snapshot) {
      const rawEl = document.getElementById('liveSnapshotRaw');
      if (rawEl) {
        try {
          rawEl.value = JSON.stringify(snapshot, null, 2);
        } catch {
          rawEl.value = '';
        }
      }

      const tbody = document.getElementById('liveSnapshotTableBody');
      if (!tbody) return;
      tbody.innerHTML = '';

      const ts = String(snapshot && snapshot.ts ? snapshot.ts : '');
      const lockExists = Boolean(get(snapshot, ['lock', 'exists'], false));

      const tempFiles = safeNumber(get(snapshot, ['dirs', 'temporary', 'files'], 0));
      const activeFiles = safeNumber(get(snapshot, ['dirs', 'active', 'files'], 0));
      const holdingFiles = safeNumber(get(snapshot, ['dirs', 'holding', 'files'], 0));

      const metricsRunExists = Boolean(get(snapshot, ['files', 'metrics_run', 'exists'], false));
      const metricsCompareExists = Boolean(get(snapshot, ['files', 'metrics_compare', 'exists'], false));

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${ts}</td>
        <td>${_fmtBool(lockExists)}</td>
        <td>${Math.trunc(tempFiles)}</td>
        <td>${Math.trunc(activeFiles)}</td>
        <td>${Math.trunc(holdingFiles)}</td>
        <td>${_fmtBool(metricsRunExists)}</td>
        <td>${_fmtBool(metricsCompareExists)}</td>
      `;
      tbody.appendChild(tr);
    }

    async function loadLiveSnapshotFromPicker() {
      try {
        const input = document.getElementById('liveSnapshotFile');
        if (!input || !input.files || !input.files.length) {
          setLiveSnapshotStatus('no file selected', 'warn');
          return;
        }
        const obj = await readJsonFile(input.files[0]);
        renderLiveSnapshot(obj);
        setLiveSnapshotStatus('loaded', 'ok');
      } catch (e) {
        setLiveSnapshotStatus('load failed', 'bad');
      }
    }

    async function fetchLiveSnapshotOnce() {
      const base = _getBase();
      const url = `${base}/${LIVE_SNAPSHOT_PATH}`;
      try {
        setLiveSnapshotStatus('fetching...', 'warn');
        const r = await fetch(url, { cache: 'no-store' });
        if (!r.ok) {
          setLiveSnapshotStatus(`fetch ${r.status}`, 'bad');
          return;
        }
        const obj = await r.json();
        renderLiveSnapshot(obj);
        setLiveSnapshotStatus('ok', 'ok');
      } catch {
        setLiveSnapshotStatus('fetch error', 'bad');
      }
    }

    let _liveSnapshotTimer = null;
    function toggleLiveSnapshotAutorefresh() {
      if (_liveSnapshotTimer) {
        clearInterval(_liveSnapshotTimer);
        _liveSnapshotTimer = null;
        setLiveSnapshotStatus('auto-refresh off', '');
        return;
      }

      const iv = _parseIntSafe((document.getElementById('liveSnapshotInterval') || {}).value, 10);
      const intervalMs = Math.max(2, Math.min(iv, 600)) * 1000;
      _liveSnapshotTimer = setInterval(() => { fetchLiveSnapshotOnce(); }, intervalMs);
      setLiveSnapshotStatus('auto-refresh on', 'ok');
      fetchLiveSnapshotOnce();
    }

    function _getQueryParam(name) {
      try {
        const u = new URL(window.location.href);
        return u.searchParams.get(name);
      } catch {
        return null;
      }
    }

    function getServerMetricsMode() {
      // Priority: query param -> localStorage -> current select -> default.
      const qp = String(_getQueryParam('metrics') || '').toLowerCase();
      if (qp === 'compare' || qp === 'run') return qp;

      try {
        const saved = String(localStorage.getItem('dashboard_metrics_server_mode') || '').toLowerCase();
        if (saved === 'compare' || saved === 'run') return saved;
      } catch {
        // ignore
      }

      const el = document.getElementById('metricsServerSource');
      const v = String(el?.value || '').toLowerCase();
      if (v === 'compare' || v === 'run') return v;
      return 'run';
    }

    function setServerMetricsMode(mode) {
      const m = (String(mode || '').toLowerCase() === 'compare') ? 'compare' : 'run';
      const el = document.getElementById('metricsServerSource');
      if (el) el.value = m;
      try {
        localStorage.setItem('dashboard_metrics_server_mode', m);
      } catch {
        // ignore
      }
      return m;
    }

    function extractScenarioId(report, fallbackName='') {
      return (
        get(report, ['scenario_id'], null) ||
        get(report, ['scenario'], null) ||
        get(report, ['id'], null) ||
        get(report, ['task', 'scenario_id'], null) ||
        fallbackName ||
        'unknown'
      );
    }

    function extractTaskId(report) {
      return (
        get(report, ['task_id'], null) ||
        get(report, ['task', 'task_id'], null) ||
        get(report, ['task', 'id'], null) ||
        get(report, ['task', 'target_record_id'], null) ||
        ''
      );
    }

    function extractValidation(report) {
      return (
        get(report, ['validation'], null) ||
        get(report, ['task', 'validation'], null) ||
        get(report, ['result', 'validation'], null) ||
        null
      );
    }

    function extractN(report) {
      const v = extractValidation(report);
      const n = get(v || {}, ['n'], null);
      if (n === null || n === undefined) return null;
      if (typeof n === 'string' && n.trim() === '') return null;
      const nn = Number(n);
      return Number.isFinite(nn) ? nn : null;
    }

    function extractSeed(report) {
      const v = extractValidation(report) || {};
      return (
        get(report, ['deterministic_seed'], null) ||
        get(report, ['seed_obj', 'seed'], null) ||
        get(v, ['seed'], null) ||
        get(report, ['task', 'deterministic_seed'], null) ||
        get(report, ['result', 'deterministic_seed'], null) ||
        ''
      );
    }

    function extractPassFail(report) {
      const v = extractValidation(report) || {};
      const resultObj = get(report, ['result'], null);
      const res = (resultObj && typeof resultObj === 'object') ? resultObj : {};

      const scenarioId = String(extractScenarioId(report, '') || '').toUpperCase();
      const status = String(
        get(report, ['status'], '') ||
        get(report, ['task', 'status'], '') ||
        get(report, ['result', 'task_status'], '') ||
        get(report, ['result', 'status'], '') ||
        ''
      ).toLowerCase();
      const validationResult = String(get(v, ['result'], '') || '').toLowerCase();

      // Scenario-specific semantics (matches adversarial harness intent).
      if (scenarioId.startsWith('S1')) {
        if (get(res, ['rolled_back'], null) === true) return 'FAIL';
        if (String(get(res, ['task_status'], '') || '').toLowerCase() === 'validated') return 'PASS';
      }

      if (scenarioId.startsWith('S2')) {
        if (get(res, ['needs_review'], null) === true) return 'NEEDS_REVIEW';
        if (String(get(res, ['task_status'], '') || '').toLowerCase() === 'needs_review') return 'NEEDS_REVIEW';
      }

      if (scenarioId.startsWith('S3')) {
        if (get(res, ['mis_association'], null) === true) return 'PASS';
        if (get(res, ['mis_association'], null) === false) return 'FAIL';
      }

      if (scenarioId.startsWith('S4')) {
        if (get(res, ['flagged'], null) === true) return 'PASS';
        if (get(res, ['flagged'], null) === false) return 'FAIL';
      }

      if (scenarioId.startsWith('S5')) {
        const action = String(get(res, ['escalation_action'], '') || '').toLowerCase();
        if (action === 'escalate') return 'ESCALATED';
        if (action) return action.toUpperCase();
      }

      if (scenarioId.startsWith('S6')) {
        if (get(res, ['negative_gain'], null) === true) return 'FAIL';
        if (get(res, ['re_evaluate'], null) === true) return 'ESCALATED';
      }

      // Common schema: validated/rolled_back.
      if (get(res, ['rolled_back'], null) === true) return 'FAIL';
      if (status.includes('validated')) return 'PASS';
      if (status.includes('needs_review')) return 'NEEDS_REVIEW';

      if (status.includes('fail') || validationResult.includes('fail')) return 'FAIL';
      if (status.includes('pass') || validationResult.includes('pass')) return 'PASS';

      // Heuristic: if a boolean exists.
      const ok = get(report, ['ok'], null);
      if (ok === true) return 'PASS';
      if (ok === false) return 'FAIL';

      // Fallback: escalation / re-evaluate.
      if (validationResult.includes('escal')) return 'ESCALATED';
      if (get(res, ['re_evaluate'], null) === true) return 'ESCALATED';

      return status ? status.toUpperCase() : (validationResult ? validationResult.toUpperCase() : 'UNKNOWN');
    }

    function extractEscalation(report) {
      const v = extractValidation(report) || {};
      const resultObj = get(report, ['result'], null);
      const res = (resultObj && typeof resultObj === 'object') ? resultObj : {};
      const escalated = (
        get(report, ['task', 'escalated'], null) === true ||
        get(report, ['escalated'], null) === true ||
        String(get(v, ['result'], '') || '').toLowerCase() === 'escalated' ||
        String(get(report, ['task', 'status'], '') || '').toLowerCase() === 'needs_review' ||
        String(get(res, ['task_status'], '') || '').toLowerCase() === 'needs_review' ||
        get(res, ['needs_review'], null) === true ||
        String(get(res, ['escalation_action'], '') || '').toLowerCase() === 'escalate' ||
        get(report, ['result', 're_evaluate'], null) === true ||
        get(report, ['result', 'rolled_back'], null) === true
      );

      const retryCount = (
        get(report, ['task', 'retry_count'], null) ||
        get(report, ['retry_count'], null) ||
        get(report, ['task', 'attempts'], null) ||
        get(res, ['attempts'], null) ||
        (Array.isArray(get(res, ['failures'], null)) ? get(res, ['failures'], []).length : null) ||
        ''
      );

      const reason = (
        get(report, ['task', 'escalation_reason'], null) ||
        get(report, ['escalation_reason'], null) ||
        get(report, ['reason'], null) ||
        get(v, ['reason'], null) ||
        get(res, ['escalation_reason'], null) ||
        ''
      );

      return { escalated: Boolean(escalated), retryCount, reason };
    }

    async function readJsonFile(file) {
      const text = await file.text();
      return JSON.parse(text);
    }

    async function readTextFile(file) {
      return await file.text();
    }

    function renderKpis(metrics, reports) {
      const adaptiveUsed = safeNumber(metrics['resolution_adaptive_used_total']);
      const adaptiveSamples = safeNumber(metrics['resolution_adaptive_samples_total']);
      const earlyStop = safeNumber(metrics['resolution_adaptive_early_stop_total']);
      const escalations = safeNumber(metrics['resolution_rollback_storm_escalations_total']);

      const avgAdaptiveN = adaptiveUsed > 0 ? (adaptiveSamples / adaptiveUsed) : 0;
      const earlyStopRate = adaptiveUsed > 0 ? (earlyStop / adaptiveUsed) : 0;

      // From reports: average n when present.
      const ns = reports.map(r => extractN(r.data)).filter(n => n != null);
      const avgReportN = ns.length ? (ns.reduce((a,b)=>a+b,0)/ns.length) : 0;

      const kpis = [
        { label: 'adaptive_used_total', value: String(Math.trunc(adaptiveUsed)) },
        { label: 'avg_samples_per_validation', value: (avgReportN ? avgReportN.toFixed(2) : avgAdaptiveN.toFixed(2)) },
        { label: 'early_stop_rate', value: earlyStopRate.toFixed(3) },
        { label: 'escalations_total', value: String(Math.trunc(escalations)) },
      ];

      const el = document.getElementById('kpis');
      if (!el) return;
      el.innerHTML = '';
      for (const k of kpis) {
        const d = document.createElement('div');
        d.className = 'kpi';
        d.innerHTML = `<div class="label">${k.label}</div><div class="value">${k.value}</div>`;
        el.appendChild(d);
      }
    }

    function renderCountersChart(metrics) {
      const el = document.getElementById('chartCounters');
      if (!window.Plotly || typeof Plotly.newPlot !== 'function') {
        if (el) {
          el.classList.add('hint-only');
          el.innerHTML = '<div class="hint">Charts unavailable: Plotly failed to load (offline/blocked). Tables and raw JSON still work.</div>';
        }
        return;
      }
      if (el) {
        el.classList.remove('hint-only');
        el.innerHTML = '';
      }
      const keys = DEFAULT_COUNTER_KEYS;
      const values = keys.map(k => safeNumber(metrics[k] || 0));

      const trace = {
        x: keys,
        y: values,
        type: 'bar',
        marker: { color: '#66d9ef' }
      };

      const layout = {
        title: { text: 'Metrics counters (metrics.json)', font: { color: '#e7eef8', size: 14 } },
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        font: { color: '#e7eef8' },
        margin: { l: 40, r: 10, t: 40, b: 90 },
        xaxis: { tickangle: -25, automargin: true },
        yaxis: { automargin: true }
      };

      try {
        Plotly.newPlot('chartCounters', [trace], layout, {responsive: true, displayModeBar: false});
      } catch {
        if (el) {
          el.classList.add('hint-only');
          el.innerHTML = '<div class="hint">Charts error: Plotly rendering failed. Tables and raw JSON still work.</div>';
        }
      }
    }

    function renderHistogram(reports) {
      const el = document.getElementById('chartHistogram');
      if (!window.Plotly || typeof Plotly.newPlot !== 'function') {
        if (el) {
          el.classList.add('hint-only');
          el.innerHTML = '<div class="hint">Charts unavailable: Plotly failed to load (offline/blocked). Tables and raw JSON still work.</div>';
        }
        return;
      }
      if (el) {
        el.classList.remove('hint-only');
        el.innerHTML = '';
      }
      const ns = reports.map(r => extractN(r.data)).filter(n => n != null);
      const trace = {
        x: ns,
        type: 'histogram',
        marker: { color: '#a6e22e' },
        nbinsx: 20
      };

      const layout = {
        title: { text: 'Sample count distribution (from adversarial reports)', font: { color: '#e7eef8', size: 14 } },
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        font: { color: '#e7eef8' },
        margin: { l: 40, r: 10, t: 40, b: 40 },
        xaxis: { title: 'n', automargin: true },
        yaxis: { title: 'count', automargin: true }
      };

      try {
        Plotly.newPlot('chartHistogram', [trace], layout, {responsive: true, displayModeBar: false});
      } catch {
        if (el) {
          el.classList.add('hint-only');
          el.innerHTML = '<div class="hint">Charts error: Plotly rendering failed. Tables and raw JSON still work.</div>';
        }
      }
    }

    function renderPie(metrics) {
      const el = document.getElementById('chartPie');
      if (!window.Plotly || typeof Plotly.newPlot !== 'function') {
        if (el) {
          el.classList.add('hint-only');
          el.innerHTML = '<div class="hint">Charts unavailable: Plotly failed to load (offline/blocked). Tables and raw JSON still work.</div>';
        }
        return;
      }
      if (el) {
        el.classList.remove('hint-only');
        el.innerHTML = '';
      }
      const used = safeNumber(metrics['resolution_adaptive_used_total']);
      const early = safeNumber(metrics['resolution_adaptive_early_stop_total']);
      const nonEarly = Math.max(0, used - early);

      if (used <= 0) {
        if (el) {
          el.classList.add('hint-only');
          el.innerHTML = '<div class="hint">No adaptive sampling activity yet (`resolution_adaptive_used_total` is 0), so the early-stop pie chart is empty.</div>';
        }
        return;
      }

      const trace = {
        labels: ['early_stop', 'non_early_stop'],
        values: [early, nonEarly],
        type: 'pie',
        marker: { colors: ['#fd971f', '#66d9ef'] }
      };

      const layout = {
        title: { text: 'Early stop vs non-early (from metrics)', font: { color: '#e7eef8', size: 14 } },
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        font: { color: '#e7eef8' },
        margin: { l: 10, r: 10, t: 40, b: 10 },
        showlegend: true
      };

      try {
        Plotly.newPlot('chartPie', [trace], layout, {responsive: true, displayModeBar: false});
      } catch {
        if (el) {
          el.classList.add('hint-only');
          el.innerHTML = '<div class="hint">Charts error: Plotly rendering failed. Tables and raw JSON still work.</div>';
        }
      }
    }

    function renderEscalationTable(reports) {
      const tbody = document.querySelector('#escalationTable tbody');
      const empty = document.getElementById('escalationEmpty');
      if (!tbody || !empty) return;

      tbody.innerHTML = '';
      const rows = [];

      for (const r of reports) {
        const sid = extractScenarioId(r.data, r.name);
        const taskId = extractTaskId(r.data);
        const esc = extractEscalation(r.data);
        if (!esc.escalated) continue;

        rows.push({
          file: r.name,
          scenario: sid,
          taskId,
          retry: esc.retryCount,
          reason: String(esc.reason || '').slice(0, 160)
        });
      }

      if (!rows.length) {
        empty.style.display = 'block';
        return;
      }

      empty.style.display = 'none';
      for (const row of rows) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${escapeHtml(row.file)}</td>
          <td>${escapeHtml(String(row.scenario))}</td>
          <td>${escapeHtml(String(row.taskId || ''))}</td>
          <td>${escapeHtml(String(row.retry || ''))}</td>
          <td>${escapeHtml(String(row.reason || ''))}</td>
        `;
        tbody.appendChild(tr);
      }
    }

    function renderScenarioTable(reports) {
      const tbody = document.querySelector('#scenarioTable tbody');
      if (!tbody) return;

      tbody.innerHTML = '';
      const rows = [];

      for (const r of reports) {
        const sid = extractScenarioId(r.data, r.name);
        const pf = extractPassFail(r.data);
        const n = extractN(r.data);
        const seed = extractSeed(r.data);

        rows.push({
          scenario: sid,
          pf,
          n: (n == null ? '' : String(n)),
          seed: (seed == null ? '' : String(seed)),
          file: r.name
        });
      }

      rows.sort((a,b) => String(a.scenario).localeCompare(String(b.scenario)));

      for (const row of rows) {
        const tagClass = (String(row.pf).toUpperCase().includes('PASS')) ? 'good' : (String(row.pf).toUpperCase().includes('FAIL') ? 'bad' : '');
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${escapeHtml(String(row.scenario))}</td>
          <td><span class="tag ${tagClass}">${escapeHtml(String(row.pf))}</span></td>
          <td>${escapeHtml(String(row.n))}</td>
          <td>${escapeHtml(String(row.seed))}</td>
          <td>${escapeHtml(String(row.file))}</td>
        `;
        tbody.appendChild(tr);
      }
    }

    function renderRawMetrics(rawText) {
      const ta = document.getElementById('rawMetrics');
      if (!ta) return;
      ta.value = rawText || '';
    }

    function setupSweepDownload(text) {
      const link = document.getElementById('downloadSweep');
      if (!link) return;
      if (!text) {
        link.style.display = 'none';
        link.href = '#';
        return;
      }
      const blob = new Blob([text], {type: 'text/csv'});
      const url = URL.createObjectURL(blob);
      link.href = url;
      link.download = 'sweep_results.csv';
      link.style.display = 'inline-block';
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    async function loadFromPickers() {
      const metricsEl = document.getElementById('metricsFile');
      const reportsEl = document.getElementById('reportsFiles');
      const sweepEl = document.getElementById('sweepCsv');

      let metricsPayload = {};
      let metricsRawText = '';
      let reports = [];
      let sweepText = '';

      if (metricsEl && metricsEl.files && metricsEl.files.length) {
        const file = metricsEl.files[0];
        metricsRawText = await file.text();
        try {
          metricsPayload = JSON.parse(metricsRawText);
        } catch {
          metricsPayload = {};
        }
      }

      if (reportsEl && reportsEl.files && reportsEl.files.length) {
        for (const f of reportsEl.files) {
          try {
            const data = await readJsonFile(f);
            reports.push({ name: f.name, data });
          } catch {
            // skip
          }
        }
      }

      if (sweepEl && sweepEl.files && sweepEl.files.length) {
        sweepText = await readTextFile(sweepEl.files[0]);
      }

      return { metricsPayload, metricsRawText, reports, sweepText };
    }

    async function tryFetchDefaults() {
      // This only works in server mode (http://) due to browser security.
      // We cannot list directories, so we attempt a small set of known filenames.
      setStatus('fetching...', '');

      window.__fetchLog = [];
      function _logFetch(url, status, note='') {
        try {
          window.__fetchLog.push({ ts: Date.now(), url, status, note });
          const el = document.getElementById('fetchLog');
          if (el) {
            const lines = window.__fetchLog.map(e => {
              const code = (e.status === null || e.status === undefined) ? 'ERR' : String(e.status);
              const extra = e.note ? ` (${e.note})` : '';
              return `${code} ${e.url}${extra}`;
            });
            el.textContent = lines.join('\n');
          }
        } catch {
          // ignore
        }
      }

      const base = (document.getElementById('basePath')?.value || '.').replace(/\/+$/, '');
      const metricsMode = getServerMetricsMode();
      const metricsRel = METRICS_SERVER_PATHS[metricsMode] || METRICS_SERVER_PATHS.run;
      const candidates = [
        `${base}/${metricsRel}`,
        `${base}/metrics.json`,
      ];

      const indexCandidates = [
        `${base}/adversarial_run_index.json`,
        `${base}/TemporaryQueue/adversarial_run_index.json`,
      ];

      const reportFilenames = [
        'adversarial_report_S1_small_noise.json',
        'adversarial_report_S2_large_outlier.json',
        'adversarial_report_S3_context_swap.json',
        'adversarial_report_S4_poisoned_retrieval.json',
        'adversarial_report_S5_rollback_storm.json',
        'adversarial_report_S6_counterfactual_negative_gain.json',
      ];

      async function tryFetchJson(url) {
        try {
          const r = await fetch(url, { cache: 'no-store' });
          _logFetch(url, r.status, r.ok ? '' : 'not ok');
          if (!r.ok) return null;
          return await r.json();
        } catch (e) {
          _logFetch(url, null, (e && e.message) ? String(e.message) : 'fetch error');
          return null;
        }
      }

      let metricsPayload = {};
      let metricsRawText = '';
      for (const url of candidates) {
        try {
          const r = await fetch(url, { cache: 'no-store' });
          _logFetch(url, r.status, r.ok ? '' : 'not ok');
          if (!r.ok) continue;
          metricsRawText = await r.text();
          metricsPayload = JSON.parse(metricsRawText);
          break;
        } catch {
          _logFetch(url, null, 'fetch error');
          // continue
        }
      }

      const reports = [];

      // Prefer the adversarial run index (if present) to discover report paths.
      const seenReportUrls = new Set();
      for (const url of indexCandidates) {
        const idx = await tryFetchJson(url);
        if (!idx || !Array.isArray(idx.reports)) continue;
        for (const entry of idx.reports) {
          const rf = entry && typeof entry === 'object' ? (entry.report_file || entry.file || '') : '';
          if (!rf) continue;
          const rel = String(rf).replace(/^\/+/, '').replace(/^\.\/+/, '');
          const reportUrl = `${base}/${rel}`;
          if (seenReportUrls.has(reportUrl)) continue;
          seenReportUrls.add(reportUrl);
          const data = await tryFetchJson(reportUrl);
          if (!data) continue;
          const name = reportUrl.split('/').slice(-1)[0];
          reports.push({ name, data });
        }
        break;
      }

      // Fallback: try known filenames in TemporaryQueue first, then repo-root only if needed.
      for (const fn of reportFilenames) {
        const tqUrl = `${base}/TemporaryQueue/${fn}`;
        const rootUrl = `${base}/${fn}`;

        if (!seenReportUrls.has(tqUrl)) {
          const data = await tryFetchJson(tqUrl);
          if (data) {
            seenReportUrls.add(tqUrl);
            reports.push({ name: fn, data });
            continue;
          }
        }

        if (!seenReportUrls.has(rootUrl)) {
          const data = await tryFetchJson(rootUrl);
          if (data) {
            seenReportUrls.add(rootUrl);
            reports.push({ name: fn, data });
          }
        }
      }

      // Attempt sweep csv.
      let sweepText = '';
      try {
        const r = await fetch(`${base}/TemporaryQueue/sweep_results.csv`, { cache: 'no-store' });
        _logFetch(`${base}/TemporaryQueue/sweep_results.csv`, r.status, r.ok ? '' : 'not ok');
        if (r.ok) sweepText = await r.text();
      } catch {
        _logFetch(`${base}/TemporaryQueue/sweep_results.csv`, null, 'fetch error');
        // ignore
      }

      if (!metricsRawText && !reports.length) {
        setStatus('fetch failed', 'bad');
        alert('Fetch defaults failed. Use file pickers, or run a local server (python -m http.server) from repo root.');
        return;
      }

      window.__loaded = { metricsPayload, metricsRawText, reports, sweepText };
      setStatus('fetched', 'good');
      renderFromLoaded(window.__loaded);
    }

    async function generateCompareAndLoadDefaults() {
      // Convenience button: run the compare flush script via the local dashboard server,
      // then load the recommended defaults (metrics + adversarial reports).
      // This only works in server mode (http://127.0.0.1:8000/...).
      setStatus('generating...', '');

      window.__fetchLog = window.__fetchLog || [];
      function _logFetch(url, status, note='') {
        try {
          window.__fetchLog.push({ ts: Date.now(), url, status, note });
          const el = document.getElementById('fetchLog');
          if (el) {
            const lines = window.__fetchLog.map(e => {
              const code = (e.status === null || e.status === undefined) ? 'ERR' : String(e.status);
              const extra = e.note ? ` (${e.note})` : '';
              return `${code} ${e.url}${extra}`;
            });
            el.textContent = lines.join('\n');
          }
        } catch {
          // ignore
        }
      }

      const base = (document.getElementById('basePath')?.value || '.').replace(/\/+$/, '');
      const url = `${base}/api/compare_flush`;

      try {
        // Ensure the dashboard is in compare mode so it loads metrics_compare.json afterwards.
        setServerMetricsMode('compare');

        const r = await fetch(url, {
          method: 'POST',
          headers: {
            'X-AI-Algorithms-Dashboard': '1',
          },
          cache: 'no-store',
        });
        _logFetch(url, r.status, r.ok ? '' : 'not ok');

        const payload = await r.json().catch(() => ({}));
        if (!r.ok || !payload || payload.ok !== true) {
          setStatus('generate failed', 'bad');
          const err = (payload && (payload.error || payload.stderr)) ? String(payload.error || payload.stderr) : 'unknown error';
          alert(`Compare metrics generation failed.\n\n${err}`);
          return;
        }

        setStatus('generated', 'good');
        await tryFetchDefaults();
      } catch (e) {
        _logFetch(url, null, (e && e.message) ? String(e.message) : 'fetch error');
        setStatus('generate error', 'bad');
        alert('Could not generate compare metrics. Ensure the dashboard server is running and reload the page.');
      }
    }

    function renderFromLoaded(loaded) {
      const metrics = detectMetricsRoot(loaded.metricsPayload || {}) || {};
      const reports = loaded.reports || [];

      renderKpis(metrics, reports);
      renderCountersChart(metrics);
      renderHistogram(reports);
      renderPie(metrics);
      renderEscalationTable(reports);
      renderScenarioTable(reports);
      renderRawMetrics(loaded.metricsRawText || '');
      setupSweepDownload(loaded.sweepText || '');

      setStatus('rendered', 'good');
    }

    async function renderAll() {
      setStatus('loading...', '');
      try {
        const loaded = await loadFromPickers();
        window.__loaded = loaded;
        renderFromLoaded(loaded);
      } catch (e) {
        console.error(e);
        setStatus('error', 'bad');
        alert('Error rendering dashboard. Check console for details.');
      }
    }

    function _hasQueryFlag(name) {
      try {
        const u = new URL(window.location.href);
        const v = (u.searchParams.get(name) || '').toLowerCase();
        return v === '1' || v === 'true' || v === 'yes' || v === 'on';
      } catch {
        return false;
      }
    }

    (function init() {
      setStatus('idle', '');
      setInitialPlaceholders();

      // Initialize server metrics source selector.
      setServerMetricsMode(getServerMetricsMode());
      const sel = document.getElementById('metricsServerSource');
      if (sel) {
        sel.addEventListener('change', () => {
          setServerMetricsMode(sel.value);
        });
      }

      // Optional convenience for Simple Browser: auto-fetch in server mode.
      // Use: dashboard.html?autofetch=1
      // Shell-safe alternatives (no '&' needed):
      // - dashboard.html?autofetch=compare
      // - dashboard.html?autofetch=run
      const af = String(_getQueryParam('autofetch') || '').toLowerCase();
      if (af === 'compare' || af === 'run') {
        setServerMetricsMode(af);
        tryFetchDefaults().catch(() => {});
      } else if (_hasQueryFlag('autofetch')) {
        tryFetchDefaults().catch(() => {});
      }
    })();
  </script>
</body>
</html>
